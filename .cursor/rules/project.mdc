---
description: Core Open Agent architecture - hierarchical agent system with full machine access
alwaysApply: true
---

# Open Agent

Minimal autonomous coding agent in Rust with **full machine access** (not sandboxed).

## Quick Reference

| Component | Location | Purpose |
|-----------|----------|---------|
| Backend (Rust) | `src/` | HTTP API + agent system |
| Dashboard (Next.js) | `dashboard/` | Web UI (Bun, not npm) |
| MCP configs | `.open_agent/mcp/config.json` | Model Context Protocol servers |
| Tuning | `.open_agent/tuning.json` | Calibration data |

## Architecture

```
RootAgent (orchestrator)
├── ComplexityEstimator (leaf) → estimates task difficulty 0-1
├── ModelSelector (leaf) → U-curve cost optimization
├── TaskExecutor (leaf) → runs tools in a loop
└── Verifier (leaf) → hybrid programmatic + LLM verification
```

### Module Map

```
src/
├── agents/           # Hierarchical agent system
│   ├── orchestrator/ # RootAgent, NodeAgent
│   └── leaf/         # ComplexityEstimator, ModelSelector, TaskExecutor, Verifier
├── budget/           # Cost tracking, pricing, smart retry
├── memory/           # Supabase + pgvector persistence + context building
│   ├── supabase.rs   # Database client
│   ├── context.rs    # ContextBuilder, SessionContext, MemoryContext
│   ├── retriever.rs  # Semantic search
│   └── writer.rs     # Event recording
├── mcp/              # MCP server registry + config
├── llm/              # OpenRouter client
├── tools/            # File ops, terminal, git, web, search, desktop, storage, memory
├── task/             # Task types + verification
├── config.rs         # Config, MemoryConfig, ContextConfig
└── api/              # HTTP routes (axum)
```

## Agent Rules

1. **Full system access**: Can read/write any file, execute any command, search anywhere
2. **Working directory**: `WORKING_DIR` env (default: `/root` prod, `.` dev) - paths can be relative or absolute
3. **Directory structure** (production):
   - `/root/context/` - user uploads (dashboard file explorer)
   - `/root/work/` - agent working area (subfolders per task)
   - `/root/tools/` - reusable scripts (auto-discovered by TaskExecutor)

## API Endpoints

| Method | Path | Purpose |
|--------|------|---------|
| `POST` | `/api/task` | Submit task |
| `GET` | `/api/task/{id}` | Get status |
| `GET` | `/api/task/{id}/stream` | SSE progress |
| `GET` | `/api/health` | Health check |
| `GET` | `/api/runs` | List archived runs |
| `GET/POST/DELETE` | `/api/mcp/*` | MCP management |

## Model Selection (U-Curve)

- **Cheap models**: low token cost, high failure rate, more retries
- **Expensive models**: high token cost, low failure rate
- **Optimal**: minimizes `E[total_cost] = Σ P(retry_n) × cost_n`

Default ladder: `claude-haiku-4.5` → `claude-3.5-sonnet` → `claude-sonnet-4.5`

## Smart Retry

Analyzes failure signals to decide action:

| Failure Mode | Signals | Action |
|--------------|---------|--------|
| Capability insufficient | stuck in loops, repetitive | **Upgrade** model |
| Budget exhausted + progress | files modified, high tool success | **Continue** or cheaper |
| External error | API/network issues | **Retry** same config |
| Infeasible | consistent failures | **Stop** |

## Desktop Automation

When `DESKTOP_ENABLED=true`, the agent has access to desktop automation tools:

| Tool | Purpose |
|------|---------|
| `desktop_start_session` | Start Xvfb + i3 virtual desktop |
| `desktop_stop_session` | Clean up desktop session |
| `desktop_screenshot` | Capture screen (returns PNG path) |
| `desktop_type` | Type text or send key combos |
| `desktop_click` | Mouse click at coordinates |
| `desktop_get_text` | Extract text via AT-SPI or OCR |
| `desktop_mouse_move` | Move mouse without clicking |
| `desktop_scroll` | Scroll wheel at position |

Setup: See `docs/DESKTOP_SETUP.md` and run `scripts/install_desktop.sh` on server.

## Image Sharing

The agent can share images in markdown using the `upload_image` tool:

| Tool | Purpose |
|------|---------|
| `upload_image` | Upload local image to Supabase Storage, returns public URL |

**Usage:**
1. Take a screenshot or create an image file
2. Use `upload_image` with the file path
3. Include the returned markdown `![description](url)` in your response

**Supabase Storage:**
- Bucket: `images` (public, created in Supabase dashboard)
- Public URL format: `https://<project>.supabase.co/storage/v1/object/public/images/<file>`
- Supported formats: PNG, JPEG, GIF, WebP, SVG

## Memory System

The agent has a layered memory system inspired by ChatGPT's architecture:

### Memory Layers

| Layer | Description | Injection |
|-------|-------------|-----------|
| **Session Metadata** | Time, working dir, context files | Every system prompt |
| **User Facts** | Stored preferences and project info | Every system prompt (configurable) |
| **Mission Summaries** | Past mission learnings with embeddings | Every system prompt (configurable) |
| **Task Chunks** | Semantic search over past task outputs | On-demand via RAG |

### Memory Tools

| Tool | Purpose |
|------|---------|
| `search_memory` | Search past tasks, missions, and facts |
| `store_fact` | Store user preferences or project info |

### Database Tables

Required tables in Supabase (see `docs/MEMORY_TABLES.sql`):
- `user_facts` - Long-term user/project facts with embeddings
- `mission_summaries` - Learnings from completed missions

## Context System

Context injection is managed by `ContextBuilder` (`src/memory/context.rs`) with centralized configuration.

### ContextConfig (`src/config.rs`)

All context-related limits are configurable via environment variables:

| Setting | Env Var | Default | Description |
|---------|---------|---------|-------------|
| History messages | `CONTEXT_MAX_HISTORY_MESSAGES` | 10 | Max conversation messages to include |
| Message chars | `CONTEXT_MAX_MESSAGE_CHARS` | 5000 | Max chars per message |
| History total | `CONTEXT_MAX_HISTORY_CHARS` | 30000 | Total history context limit |
| Memory chunks | `CONTEXT_MEMORY_CHUNK_LIMIT` | 3 | Relevant past chunks to retrieve |
| Chunk threshold | `CONTEXT_MEMORY_THRESHOLD` | 0.6 | Similarity threshold (0-1) |
| User facts | `CONTEXT_USER_FACTS_LIMIT` | 10 | User facts to inject |
| Mission summaries | `CONTEXT_MISSION_SUMMARIES_LIMIT` | 5 | Recent summaries to inject |
| Tool results | `CONTEXT_MAX_TOOL_RESULT_CHARS` | 15000 | Tool output truncation limit |

### Context Components

The `ContextBuilder` produces three structured context types:

```rust
// Session context (sync)
SessionContext { time, working_dir, context_files, mission_title }

// Memory context (async, requires DB)
MemoryContext { past_experience, user_facts, mission_summaries }

// History context (sync)
String (formatted conversation history)
```

### Automatic Context Injection

The `TaskExecutor` automatically injects:
1. **Session metadata** (time, working directory, context files)
2. **Relevant past task chunks** (via semantic search)
3. **User facts** (preferences, conventions)
4. **Recent mission summaries**

This allows the agent to learn from past experience without explicit prompting.

### Directory Structure

Context paths are derived from `ContextConfig`:
- `context/` - User uploads (read by session metadata)
- `work/` - Agent workspace
- `tools/` - Reusable scripts

## After Significant Changes

When you make architectural changes to this codebase, **update the Cursor rules**:
- New module → add to module map
- New API endpoint → add to endpoints table
- New env var → add to `secrets.mdc`
- New agent type → update architecture diagram
