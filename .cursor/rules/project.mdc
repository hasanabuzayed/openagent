---
description: Core Open Agent architecture - hierarchical agent system with full machine access
alwaysApply: true
---

# Open Agent

Minimal autonomous coding agent in Rust with **full machine access** (not sandboxed).

## Quick Reference

| Component | Location | Purpose |
|-----------|----------|---------|
| Backend (Rust) | `src/` | HTTP API + agent system |
| Dashboard (Next.js) | `dashboard/` | Web UI (Bun, not npm) |
| MCP configs | `.open_agent/mcp/config.json` | Model Context Protocol servers |
| Tuning | `.open_agent/tuning.json` | Calibration data |

## Architecture

```
RootAgent (orchestrator)
├── ComplexityEstimator (leaf) → estimates task difficulty 0-1
├── ModelSelector (leaf) → U-curve cost optimization
├── TaskExecutor (leaf) → runs tools in a loop
└── Verifier (leaf) → hybrid programmatic + LLM verification
```

### Module Map

```
src/
├── agents/           # Hierarchical agent system
│   ├── orchestrator/ # RootAgent, NodeAgent
│   └── leaf/         # ComplexityEstimator, ModelSelector, TaskExecutor, Verifier
├── budget/           # Cost tracking, pricing, smart retry
├── memory/           # Supabase + pgvector persistence
├── mcp/              # MCP server registry + config
├── llm/              # OpenRouter client
├── tools/            # File ops, terminal, git, web, search, desktop, storage, memory
├── task/             # Task types + verification
└── api/              # HTTP routes (axum)
```

## Agent Rules

1. **Full system access**: Can read/write any file, execute any command, search anywhere
2. **Working directory**: `WORKING_DIR` env (default: `/root` prod, `.` dev) - paths can be relative or absolute
3. **Directory structure** (production):
   - `/root/context/` - user uploads (dashboard file explorer)
   - `/root/work/` - agent working area (subfolders per task)
   - `/root/tools/` - reusable scripts (auto-discovered by TaskExecutor)

## API Endpoints

| Method | Path | Purpose |
|--------|------|---------|
| `POST` | `/api/task` | Submit task |
| `GET` | `/api/task/{id}` | Get status |
| `GET` | `/api/task/{id}/stream` | SSE progress |
| `GET` | `/api/health` | Health check |
| `GET` | `/api/runs` | List archived runs |
| `GET/POST/DELETE` | `/api/mcp/*` | MCP management |

## Model Selection (U-Curve)

- **Cheap models**: low token cost, high failure rate, more retries
- **Expensive models**: high token cost, low failure rate
- **Optimal**: minimizes `E[total_cost] = Σ P(retry_n) × cost_n`

Default ladder: `claude-haiku-4.5` → `claude-3.5-sonnet` → `claude-sonnet-4.5`

## Smart Retry

Analyzes failure signals to decide action:

| Failure Mode | Signals | Action |
|--------------|---------|--------|
| Capability insufficient | stuck in loops, repetitive | **Upgrade** model |
| Budget exhausted + progress | files modified, high tool success | **Continue** or cheaper |
| External error | API/network issues | **Retry** same config |
| Infeasible | consistent failures | **Stop** |

## Desktop Automation

When `DESKTOP_ENABLED=true`, the agent has access to desktop automation tools:

| Tool | Purpose |
|------|---------|
| `desktop_start_session` | Start Xvfb + i3 virtual desktop |
| `desktop_stop_session` | Clean up desktop session |
| `desktop_screenshot` | Capture screen (returns PNG path) |
| `desktop_type` | Type text or send key combos |
| `desktop_click` | Mouse click at coordinates |
| `desktop_get_text` | Extract text via AT-SPI or OCR |
| `desktop_mouse_move` | Move mouse without clicking |
| `desktop_scroll` | Scroll wheel at position |

Setup: See `docs/DESKTOP_SETUP.md` and run `scripts/install_desktop.sh` on server.

## Image Sharing

The agent can share images in markdown using the `upload_image` tool:

| Tool | Purpose |
|------|---------|
| `upload_image` | Upload local image to Supabase Storage, returns public URL |

**Usage:**
1. Take a screenshot or create an image file
2. Use `upload_image` with the file path
3. Include the returned markdown `![description](url)` in your response

**Supabase Storage:**
- Bucket: `images` (public, created in Supabase dashboard)
- Public URL format: `https://<project>.supabase.co/storage/v1/object/public/images/<file>`
- Supported formats: PNG, JPEG, GIF, WebP, SVG

## Memory System

The agent has a layered memory system inspired by ChatGPT's architecture:

### Memory Layers

| Layer | Description | Injection |
|-------|-------------|-----------|
| **Session Metadata** | Time, working dir, context files | Every system prompt |
| **User Facts** | Stored preferences and project info | Every system prompt (top 10) |
| **Mission Summaries** | Past mission learnings with embeddings | Every system prompt (top 5) |
| **Task Chunks** | Semantic search over past task outputs | On-demand via RAG |

### Memory Tools

| Tool | Purpose |
|------|---------|
| `search_memory` | Search past tasks, missions, and facts |
| `store_fact` | Store user preferences or project info |

### Database Tables

Required tables in Supabase (see `docs/MEMORY_TABLES.sql`):
- `user_facts` - Long-term user/project facts with embeddings
- `mission_summaries` - Learnings from completed missions

### Automatic Context Injection

The `TaskExecutor` automatically injects:
1. **Session metadata** (time, working directory, context files)
2. **Relevant past task chunks** (via semantic search)
3. **User facts** (preferences, conventions)
4. **Recent mission summaries**

This allows the agent to learn from past experience without explicit prompting.

## After Significant Changes

When you make architectural changes to this codebase, **update the Cursor rules**:
- New module → add to module map
- New API endpoint → add to endpoints table
- New env var → add to `secrets.mdc`
- New agent type → update architecture diagram
